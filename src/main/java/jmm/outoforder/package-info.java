/**
 * 重排序有哪3种可能性？
 * 重排序的3种情况分别是什么？
 * 解答：
 * 1. 编译器优化
 * 编译器（包括JVM，JIT编译器等）出于优化的目的（例如当前有了数据a，那么如果把对a的操作放到一起效率会更高，
 * 避免了读取b后又返回来重新读取a的时间开销），在编译的过程中会进行一定程度的重排，
 * 导致生成的机器指令和之前的字节码的顺序不一致。
 * 在刚才的例子中，编译器将y=a和b=1这两行语句换了顺序（也可能是线程2的两行换了顺序，同理），
 * 因为它们之间没有数据依赖关系，那就不难得到 x=0，y = 0 这种结果了。
 * <p>
 * 2. 指令重排序
 * CPU 的优化行为，和编译器优化很类似，是通过乱序执行的技术，来提高执行效率。所以就算编译器不发
 * 生重排，CPU 也可能对指令进行重排，所以我们开发中，一定要考虑到重排序带来的后果。
 * <p>
 * 3. 内存的“重排序”
 * 内存系统内不存在重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。
 * 由于内存有缓存的存在，在JMM里表现为主存和本地内存，由于主存和本地内存的不一致，会使得程序表现出乱序的行为。
 * 在刚才的例子中，假设没发生编译器重排和指令重排，但是如果发生了内存缓存不一致，也可能导致同样的情况：
 * 线程1修改了a的值，但是修改后并没有写回主存，所以线程2是看不到刚才线程1对a的修改的，所以线程2看到a还是等于0。
 * 同理，线程2对b的赋值操作也可能由于没及时写回主存，导致线程1看不到刚才线程2的修改。
 */
package jmm.outoforder;