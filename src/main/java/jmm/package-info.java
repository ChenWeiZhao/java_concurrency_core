/**
 * 一、从Java代码到CPU指令的变化过程？
 * 我们在Java代码中，使用的控制并发的手段例如synchronized关键字，最终也是要转化为CPU指令来生效的，
 * 从Java代码到最终执行的CPU指令的流程：
 * *    1. 最开始，编写的Java代码，是*.java文件
 * *    2. 在编译（javac命令）后，从刚才的*.java文件会变出一个新的Java字节码文件（*.class）
 * *    3. JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
 * *    4. 机器指令可以直接在CPU上运行，也就是最终的程序执行
 * 而不同的JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别；所以我们在java代码层写的各种Lock，
 * 其实最后依赖的是JVM的具体实现（不同版本会有不同实现）和CPU的指令，才能帮我们达到线程安全的效果。
 * 由于最终效果依赖处理器，不同处理器结果不一样，这样无法保证并发安全，所以需要一个标准，让多线程运行的结果可预期，这个标准就是JMM。
 *
 * 二、Java内存模型（jmm）是一组规范
 * 需要jvm遵守这些规范，便于我们利用这些规范，开发多线程程序。
 * 如果没有这样的规范，很有可能在不同jvm的不同规则重排序后，导致不同虚拟机上运行的结果不一样。
 * volatile，synchronized，lock等的原理都是jmm。如果没有jmm，就需要指定什么时候使用内存栅栏。
 * jmm最重要的3点内容：重排序，可见性，原子性
 *
 * 重排序好处：提高性能处理速度
 *
 * 可见性
 *
 */
package jmm;