/**
 * 有多少种实现线程的方法？
 * 答题思路，以下5点：
 * 1. 从不同的角度看，会有不同的答案。
 * 2. 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
 * 3. 但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的
 * run方法，会发现其实那两种本质都是一样的，run方法的代码如下：
 * <p>
 * 方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传
 * 入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来
 * 建线程。这两个方法的最主要区别在于run()方法的内容来源：
 * 方法一：最终调用target.run();
 * 方法二：run()整个都被重写
 * <p>
 * 5. 然后具体展开说其他方式；
 * 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源
 * 码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
 * <p>
 * 6. 结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方
 * 法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的r
 * 方法，然后再把该runnable实例传给Thread类。除此之外，从表面上看线程
 * 池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范
 * 围。
 * 以上这种描述比直接回答一种、两种、多种都更准确。
 * <p>
 * <p>
 * 继承Thread类后重写run()，和实现Runnable方法接口并传入thread类，哪个更好？
 * 1.从代码架构角度，这里面分为俩件事情，第一件事情是具体的任务也就是run方法里面的内容，第二件事情是和线程生命周期
 * 相关的，也是是线程的创建，运行，销毁线程，这个事情其实是Thread做的事情、所有这俩件事情应该解耦，所有使用Runnable
 * 2.新建线程的消耗： 假如我们使用了Thread，我们使用它的时候需要new它，新建线程，执行完还需要销毁，消耗资源。。使
 * 用Runnable，传入实现runnable接口实例即可，并且可以反复使用这一个实例，线程池就是这么做的，所以使用Runnable。
 * 3.扩展性 Java不支持多继承，但是可以多实现
 */
package threadcoreknowledge.createthreads;