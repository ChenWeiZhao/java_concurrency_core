/**
 * 1、为什么wait需要在同步代码块中使用，而sleep不需要？
 * 答：  为了让线程通信更加可靠，防止死锁，或者永久等待。如果不放在synchronized中，那么就有可能在线程执行到一个wait之前，
 * 切换到另一个线程。而另一个线程执行完notify后在切换回来。这样就没有线程去唤醒它了。sleep是针对自己的。
 *
 * 2、为什么线程通信的方法wait()，notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？
 *  答： 因为前3个方法是锁级别的操作，锁是属于某一个对象的，每一个对象的对象头中都含有几位用来保存当前锁的状态
 *  所以锁实际上是绑定在对象中，而并不是线程中。反过来想，若将前3个方法放在线程中，或造成很大的局限性：
 *  若某个线程持有多个锁，锁之间是相互配合，若把wait定义在线程里，就没法灵活的实现释放锁了。
 *
 * 3、调用Thread.wait会怎么样？
 * 答：因为在线程退出的时候，会自动执行notify。这样就会导致设计的流程有问题。
 *
 * 4、用3种方式实现生产者消费者模式
 *
 * 5、Java SE和Java1.8和JDK8 是什么关系？
 *
 * 6、Join和sleep和wait期间线程的状态分别是什么？为什么？
 *
 * 7、yield方法
 * 作用：释放cpu时间片，依然是可运行状态。不保证被JVM遵循。
 *
 */
package threadcoreknowledge.threadobjectclasscommonmethods;