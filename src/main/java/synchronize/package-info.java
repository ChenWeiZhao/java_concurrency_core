/**
 * synchronized关键字
 * JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行代码，从而保证线程安全，同时具有可重入和不可中断性质。
 *
 * 一、3点核心思想
 * 1、一个锁只能同时被一个线程获取，没有拿到锁的线程必须等待
 * 2、每个实例都对应自己的一把锁，不同实例之间互不影响；
 * * 例外：锁对象是*.class以及syncharonized修饰的static方法时，所有对象共用一把锁（class对象）
 * 3、无论是方法正常执行完毕还是方法抛出异常，都会释放锁
 * <p>
 * 二、原理
 * 1、加锁和释放锁原理（现象、时机、深入看JVMk按字节码）
 * * 获取和释放锁的形式：内置锁
 * * 锁是存储在java对象头中的，基于monitor对象的2个加解锁指令，monitorenter和monitorexit
 * <p>
 * 2、可重入原理：加锁次数计数器
 * * 首先每个对象都自动含有一把锁，JVM负责跟踪对象被加锁的次数，1
 * * 然后线程第一次给对象加锁的时候，计数会变为1。每当这个相同的线程在此对象上再次获得该锁时，计数会递增。
 * * 当任务离开时，计数递减，当计数为0时候，锁被完全释放
 * <p>
 * 3、保证内存可见性原理：内存模型（见图）
 * <p>
 * 三、缺陷
 * 效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程
 * 不顾灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有一个单一条件，可能是不够的
 * 无法知道是否成功获取锁
 * <p>
 * 四、常见面试问题
 * 1、synchronized关键字使用注意点
 * *  a.锁对象不能为空（锁的信息保存在对象头中的）、b.作用域不宜过大、c.避免死锁
 * <p>
 * 2、如何选择lock和synchronized关键字
 * a.优先使用线程包{@link java.util.concurrent.CountDownLatch} 或者{@link java.util.concurrent.atomic.AtomicInteger}
 * b.优先使用synchronized关键字
 * <p>
 * 3、多线程访问同步方法？：7种
 * <p>
 * 4、多个线程等待同一个synchronized锁的时候，jvm如何选择下一个获取锁的是哪一个线程？
 * *  依赖JVM版本，随机且不可控制
 * 5、synchronized使得同时只有一个线程可以执行，性能比较差，有什么办法可以提升性能？
 * *  a.优化使用范围；b.使用其它锁如读写锁
 * 6、想更灵活控制锁的获取和释放（现在锁的释放时机都被写死了）
 * *  自己去实现一个lock接口
 * 7、什么是锁的升降级？什么是JVM里的偏斜锁、轻量级锁和重量级锁？
 * *  对synchronized关键字进行优化，提升性能
 */
package synchronize;